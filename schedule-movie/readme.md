# 문제

소혜가 가장 좋아하는 만화영화인 겨울왕국이 개봉했다. 
그래서 소혜는 극장에서 최대한 관람하고 싶었다.
그런데 한가지 문제가 생겼다.
극장이 여는 중간에 밥을 먹어야 했기 때문이었다.
영화를 보는 도중에는 밥을 먹을 수 없으며,
영화를 보고 있지 않을 때에만 밥을 먹을 수 있었다.
이런 상황에서 소혜는 최대 겨울왕국을 몇 번 볼 수 있을까?

극장이 문을 여는 시간은 0이며, 문을 닫는 시간은 `closing`이다. 
영화의 러닝타임은 `running`이고, 소혜는 밥을 먹기 위해 `lunch`만큼 시간이 필요하다.
상영 시작 시간은 정수 배열인 `starts`로 나타낸다.

이동 시간은 고려하지 않는다. 
예를 들어 3시간 짜리 영화가 0시에 하나 3시에 하나 있으면 소혜는 둘 다 관람할 수 있다.

# 제한사항
* `closing`, `running`, `lunch`는 모두 자연수이며, `closing`은 `running`, `lunch`보다 크거나 같다.
* 배열 `starts`는 0 이상 `closing - running`이하의 정수로 이뤄진 정렬되어있는 배열이다. 중복되는 값은 없다.

## 테스트 셋1
* `closing`은 100,000 이하의 자연수이다.
* `starts`의 길이는 1,000 이하이다.

## 테스트 셋2
* `closing`은 10^9 이하의 자연수이다.
* `starts`의 길이는 20,000 이하이다. 

# 입출력 예
| closing | running | lunch | starts | return |
|---------|---------|-------|--------|--------|
| 5 | 5 | 3 | [0] | 0 |
| 12 | 3 | 5 | [0, 3, 6, 9] | 2 |
| 24 | 10 | 4 | [0, 7, 14] | 2 |

## 입출력 설명
### 첫번째 경우
1번 상영하며, 0시에 시작해서 5시에 끝나며 동시에 극장도 끝난다.
5시가 되기 전까지 3시간 동안 밥을 먹어야 하므로 한 번 있는 상영을 관람할 수 없다.
### 두번째 경우
상영 시간은 모두 겹치지 않지만 5시간동안 밥을 먹기 위해 연속해서 2번의 상영은 관람할 수 없다.
### 세번째 경우
0시에서 10시까지 첫번째 관람하고 10시에서 14시까지 밥을 먹고 14시에서 24시까지 두번째 관람을 한다.

# 첨언
## 솔루션
### 테스트 셋1
* Dynamic programming을 이용해서 문제를 해결할 수 있다.
* Time complexity와 space complexity는 `O(closing)`이다.

### 테스트 셋2
* `closing`가 알고리즘을 돌리기 힘들 정도로 크다.
* 아이디어는 값이 수정되어야 할 때에만 수정해서 모든 `closing`에 대해서 계산하지 않도록 한다.
* 바뀌는 구간은 (1) 영화가 시작하거나 끝날 때, (2) 영화가 끝나고 바로 밥을 먹은 경우가 있다.
