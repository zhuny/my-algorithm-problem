# 문제

소혜가 가장 좋아하는 만화영화인 겨울왕국이 개봉했다. 
그래서 소혜는 극장에서 최대한 관람하고 싶었다.
그런데 한가지 문제가 생겼다.
극장이 여는 중간에 밥을 먹어야 했기 때문이었다.
영화를 보는 도중에는 밥을 먹을 수 없으며,
영화를 보고 있지 않을 때에만 밥을 먹을 수 있다.
이런 상황에서 소혜는 최대 겨울왕국을 몇 번 볼 수 있을까?

극장이 문을 여는 시간은 0이며, 문을 닫는 시간은 `closing`이다. 
영화의 러닝타임은 `running`이고, 소혜는 밥을 먹기 위해 `lunch`만큼 시간이 필요하다.
상영 시작 시간은 정수 배열인 `starts`로 나타낸다.

소혜가 다음 행동을 할 때까지의 시간은 고려하지 않는다.
예를 들어, 러닝타임이 3시간인 영화가 2시에 하나, 5시에 하나 있으면
소혜는 2시 영화가 끝나자마자 바로 5시 영화를 보기 시작할 수 있다.
또한, 5시에 영화를 보지 않고 바로 밥을 먹기 시작할 수도 있다.

# 제한사항
* `closing`, `running`, `lunch`는 모두 자연수이며, `running`과 `lunch`는 둘 다 `closing`보다 크지 않다.
* 배열 `starts`는 0 이상 `closing - running`이하의 정수로 이뤄진 배열이다. 중복되는 값은 없다.

## 테스트 셋1
* `closing`은 100,000 이하의 자연수이다.
* `starts`의 길이는 1,000 이하이다.

## 테스트 셋2
* `closing`은 10^9 이하의 자연수이다.
* `starts`의 길이는 20,000 이하이다. 

# 입출력 예
| closing | running | lunch | starts | return |
|---------|---------|-------|--------|--------|
| 5 | 5 | 3 | [0] | 0 |
| 12 | 3 | 5 | [0, 3, 6, 9] | 2 |
| 24 | 10 | 4 | [0, 7, 14] | 2 |

## 입출력 설명
### 첫번째 경우
1번 상영하며, 영화는 0시에 시작해서 5시에 끝난다. 이와 동시에 극장도 끝난다.
5시가 되기 전까지 3시간 동안 밥을 먹어야 하므로 한 번 있는 상영을 관람할 수 없다.
### 두번째 경우
상영 시간은 모두 겹치지 않지만 5시간동안 밥을 먹기 위해 연속해서 2번의 상영은 관람할 수 없다.
### 세번째 경우
0시에서 10시까지 첫번째 관람하고 10시에서 14시까지 밥을 먹고 14시에서 24시까지 두번째 관람을 한다.

# 첨언
## 솔루션
### 테스트 셋1
* 함수 이름 : `solution_small`
* Dynamic programming을 이용해서 문제를 해결할 수 있다.
* Time complexity와 space complexity는 `O(closing)`이다.
* `starts`에 포함되는지 확인하기 위한 사전작업으로
`hash set`(파이썬의 `set`)을 만들기 위해 `O(starts.length)` 만큼의 시간이 소요된다.
쿼리시간은 `O(1)`이다. 

### 테스트 셋2
* 함수 이름 : `solution_large`
* `solution_small`함수는 `closing`이 알고리즘을 돌리기 힘들 정도로 효율적이지 않다.
* 아이디어는 값이 수정되어야 할 때에만 수정하고 모든 시간에 대해서 불필요하게 계산하지 않도록 하는 것이다.
* 고려해 주어야 하는 시점은 (1) 영화가 시작하거나 끝날 때, (2) 영화가 끝나고 바로 밥을 먹은 경우이다.

## 마무리
* `밥`이라는 요소가 안 넣으면 문제가 심심하고 넣으면 난이도가 갑자기 높아지는 것 같아서 계륵 같다.
* 상영관마다 만족도와 같은 속성을 줘서 최대로 얻을 수 있는 만족도를 구하는 문제를 냈어도 괜찮았을 것 같다.
예로 iMax는 조금 더 만족도가 높다던가 하는 요소들.
